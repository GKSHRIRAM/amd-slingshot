using IoTCircuitBuilder.Application.Interfaces;
using IoTCircuitBuilder.Domain.Entities;
using Microsoft.Extensions.Logging;
using Scriban;

namespace IoTCircuitBuilder.Infrastructure.Services;

public class CodeGeneratorService : ICodeGenerator
{
    private readonly ILogger<CodeGeneratorService> _logger;

    public CodeGeneratorService(ILogger<CodeGeneratorService> logger)
    {
        _logger = logger;
    }

    public Task<string> GenerateCodeAsync(
        Dictionary<string, string> pinMapping,
        List<Component> components,
        string logicType)
    {
        _logger.LogInformation(
            "Generating code with {MappingCount} pin assignments",
            pinMapping.Count);

        var libraries = CollectLibraries(components);
        var declarations = GenerateDeclarations(pinMapping, components);
        var setupCode = GenerateSetup(pinMapping, components);
        var loopCode = GenerateLoop(pinMapping, components, logicType);
        var pinDefines = GeneratePinDefines(pinMapping);

        var code = $@"// ═══════════════════════════════════════════════════
// Auto-generated by IoT Circuit Builder
// Board: Arduino Uno R3
// Components: {components.Count}
// ═══════════════════════════════════════════════════

{string.Join("\n", libraries.Select(l => $"#include <{l}.h>"))}

// ─── Pin Definitions ────────────────────────────────
{pinDefines}

// ─── Component Instances ────────────────────────────
{declarations}

void setup() {{
  Serial.begin(9600);
  Serial.println(""IoT Circuit Builder - Initialized"");

{setupCode}
}}

void loop() {{
{loopCode}

  delay(100);
}}
";

        return Task.FromResult(code);
    }


    // ===========================
    // LOGIC LOOP GENERATOR
    // ===========================

    private string GenerateLoop(
        Dictionary<string, string> pinMapping,
        List<Component> components,
        string logicType)
    {
        var lines = new List<string>();

        // ---------- LINE FOLLOWER ----------
        if (logicType == "line_follower")
        {
            lines.Add("  // Line follower logic");

            lines.Add("  int left = digitalRead(IR_SENSOR_0_OUT);");
            lines.Add("  int mid = digitalRead(IR_SENSOR_1_OUT);");
            lines.Add("  int right = digitalRead(IR_SENSOR_2_OUT);");

            lines.Add("  if(mid == LOW){");
            lines.Add("    analogWrite(L298N_MOTOR_DRIVER_0_ENA, 180);");
            lines.Add("    analogWrite(L298N_MOTOR_DRIVER_0_ENB, 180);");
            lines.Add("  }");
            lines.Add("  else if(left == LOW){");
            lines.Add("    analogWrite(L298N_MOTOR_DRIVER_0_ENA, 120);");
            lines.Add("    analogWrite(L298N_MOTOR_DRIVER_0_ENB, 180);");
            lines.Add("  }");
            lines.Add("  else if(right == LOW){");
            lines.Add("    analogWrite(L298N_MOTOR_DRIVER_0_ENA, 180);");
            lines.Add("    analogWrite(L298N_MOTOR_DRIVER_0_ENB, 120);");
            lines.Add("  }");
            lines.Add("  else {");
            lines.Add("    analogWrite(L298N_MOTOR_DRIVER_0_ENA, 0);");
            lines.Add("    analogWrite(L298N_MOTOR_DRIVER_0_ENB, 0);");
            lines.Add("  }");

            return string.Join("\n", lines);
        }


        // ---------- MAZE SOLVER ----------
        if (logicType == "maze_solver")
        {
            lines.Add("  // Maze solver logic");

            lines.Add("  int left = digitalRead(IR_SENSOR_0_OUT);");
            lines.Add("  int mid = digitalRead(IR_SENSOR_1_OUT);");
            lines.Add("  int right = digitalRead(IR_SENSOR_2_OUT);");

            lines.Add("  if(left == LOW){");
            lines.Add("    // turn left");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN1, LOW);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN2, HIGH);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN3, HIGH);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN4, LOW);");
            lines.Add("  }");

            lines.Add("  else if(right == LOW){");
            lines.Add("    // turn right");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN1, HIGH);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN2, LOW);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN3, LOW);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN4, HIGH);");
            lines.Add("  }");

            lines.Add("  else {");
            lines.Add("    // forward");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN1, HIGH);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN2, LOW);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN3, HIGH);");
            lines.Add("    digitalWrite(L298N_MOTOR_DRIVER_0_IN4, LOW);");
            lines.Add("  }");

            return string.Join("\n", lines);
        }


        // ---------- DEFAULT TEMPLATE ----------
        return GenerateLoopDefault(pinMapping, components);
    }


    // ===========================
    // OLD TEMPLATE LOOP (fallback)
    // ===========================

    private string GenerateLoopDefault(
        Dictionary<string, string> pinMapping,
        List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        foreach (var comp in components)
        {
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "loop"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);

                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;
                    pinValues["var_name"] = $"{comp.Type}_{idx}";

                    var rendered = parsedTmpl.Render(pinValues);

                    lines.AddRange(
                        rendered.Split('\n')
                        .Select(l => $"  {l}")
                    );
                }
            }
        }

        return string.Join("\n", lines);
    }


    // ===========================
    // OTHER METHODS (unchanged)
    // ===========================

    private List<string> CollectLibraries(List<Component> components)
    {
        var libs = new HashSet<string>();

        foreach (var comp in components)
        {
            foreach (var cl in comp.ComponentLibraries)
            {
                if (cl.IsRequired && cl.Library != null)
                    libs.Add(cl.Library.Name);
            }
        }

        return libs.ToList();
    }


    private string GeneratePinDefines(Dictionary<string, string> pinMapping)
    {
        var lines = new List<string>();

        foreach (var (key, value) in pinMapping)
        {
            if (value is "5V" or "3V3" or "GND")
                continue;

            string name = key.Replace(".", "_").ToUpperInvariant();
            string pin = value.StartsWith("D") ? value[1..] : value;

            lines.Add($"#define {name} {pin}");
        }

        return string.Join("\n", lines);
    }

    private string GenerateDeclarations(Dictionary<string, string> pinMapping, List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        foreach (var comp in components)
        {
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "declaration"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);
                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;

                    lines.Add(parsedTmpl.Render(pinValues));
                }
            }
        }

        return string.Join("\n", lines);
    }

    private string GenerateSetup(Dictionary<string, string> pinMapping, List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        foreach (var comp in components)
        {
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "setup"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);
                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;
                    pinValues["var_name"] = $"{comp.Type}_{idx}";

                    var rendered = parsedTmpl.Render(pinValues);
                    lines.AddRange(rendered.Split('\n').Select(l => $"  {l}"));
                }
            }
        }

        return string.Join("\n", lines);
    }


    private Dictionary<string, object> BuildTemplateContext(
        string instanceLabel,
        Dictionary<string, string> pinMapping)
    {
        var context = new Dictionary<string, object>();

        foreach (var (key, value) in pinMapping)
        {
            if (!key.StartsWith(instanceLabel + "."))
                continue;

            string pinName = key.Split('.')[1].ToLowerInvariant();
            string pinValue = value.StartsWith("D") ? value[1..] : value;

            context[$"pin_{pinName}"] = pinValue;
        }

        return context;
    }
}