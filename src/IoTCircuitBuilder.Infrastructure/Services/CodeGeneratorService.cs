using IoTCircuitBuilder.Application.Interfaces;
using IoTCircuitBuilder.Domain.Entities;
using Microsoft.Extensions.Logging;
using Scriban;

namespace IoTCircuitBuilder.Infrastructure.Services;

public class CodeGeneratorService : ICodeGenerator
{
    private readonly ILogger<CodeGeneratorService> _logger;

    public CodeGeneratorService(ILogger<CodeGeneratorService> logger)
    {
        _logger = logger;
    }

    public Task<string> GenerateCodeAsync(Dictionary<string, string> pinMapping, List<Component> components)
    {
        _logger.LogInformation("Generating code with {MappingCount} pin assignments", pinMapping.Count);

        var libraries = CollectLibraries(components);
        var declarations = GenerateDeclarations(pinMapping, components);
        var setupCode = GenerateSetup(pinMapping, components);
        var loopCode = GenerateLoop(pinMapping, components);
        var pinDefines = GeneratePinDefines(pinMapping);

        var code = $@"// ═══════════════════════════════════════════════════
// Auto-generated by IoT Circuit Builder
// Board: Arduino Uno R3
// Components: {components.Count}
// ═══════════════════════════════════════════════════

{string.Join("\n", libraries.Select(l => $"#include <{l}.h>"))}

// ─── Pin Definitions ────────────────────────────────
{pinDefines}

// ─── Component Instances ────────────────────────────
{declarations}

void setup() {{
  Serial.begin(9600);
  Serial.println(""IoT Circuit Builder - Initialized"");

{setupCode}
}}

void loop() {{
{loopCode}

  delay(100);  // Main loop delay
}}
";

        _logger.LogInformation("Code generation complete: {LineCount} lines", code.Split('\n').Length);
        return Task.FromResult(code);
    }

    private List<string> CollectLibraries(List<Component> components)
    {
        var libs = new HashSet<string>();
        foreach (var comp in components)
        {
            foreach (var cl in comp.ComponentLibraries)
            {
                if (cl.IsRequired && cl.Library != null)
                    libs.Add(cl.Library.Name);
            }
        }
        return libs.ToList();
    }

    private string GeneratePinDefines(Dictionary<string, string> pinMapping)
    {
        var lines = new List<string>();
        foreach (var (key, value) in pinMapping)
        {
            // Skip power/ground pins and topological (component-to-component) mappings in defines
            if (value is "5V" or "3V3" or "GND" || value.Contains('.')) continue;

            string defineName = key.Replace(".", "_").ToUpperInvariant();
            // Extract numeric pin number: D3 → 3, A0 → A0
            string pinValue = value.StartsWith("D") ? value[1..] : value;
            lines.Add($"#define {defineName} {pinValue}");
        }
        return string.Join("\n", lines);
    }

    private string GenerateDeclarations(Dictionary<string, string> pinMapping, List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        var renderedBlocks = new HashSet<string>();

        foreach (var comp in components)
        {
            // Find instance indices for this component type
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "declaration"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);
                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;

                    var rendered = parsedTmpl.Render(pinValues).Trim();
                    if (!string.IsNullOrWhiteSpace(rendered) && !renderedBlocks.Contains(rendered))
                    {
                        lines.Add(rendered);
                        renderedBlocks.Add(rendered);
                    }
                }
            }
        }

        return string.Join("\n", lines);
    }

    private string GenerateSetup(Dictionary<string, string> pinMapping, List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        foreach (var comp in components)
        {
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "setup"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);
                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;
                    pinValues["var_name"] = $"{comp.Type}_{idx}";

                    var rendered = parsedTmpl.Render(pinValues);
                    // Indent each line
                    lines.AddRange(rendered.Split('\n').Select(l => $"  {l}"));
                }
            }
        }

        return string.Join("\n", lines);
    }

    private string GenerateLoop(Dictionary<string, string> pinMapping, List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        foreach (var comp in components)
        {
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "loop"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);
                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;
                    pinValues["var_name"] = $"{comp.Type}_{idx}";

                    var rendered = parsedTmpl.Render(pinValues);
                    lines.AddRange(rendered.Split('\n').Select(l => $"  {l}"));
                }
            }
        }

        return string.Join("\n", lines);
    }

    /// <summary>
    /// Builds a template context dictionary like { "pin_out": "3", "pin_trig": "4" }
    /// from the mapping "ir_sensor_0.OUT" → "D3" (converts to pin_out → 3)
    /// </summary>
    private Dictionary<string, object> BuildTemplateContext(string instanceLabel, Dictionary<string, string> pinMapping)
    {
        var context = new Dictionary<string, object>();

        foreach (var (key, value) in pinMapping)
        {
            if (!key.StartsWith(instanceLabel + ".")) continue;

            // Skip topological pins (connections to other components) in the code context
            if (value.Contains('.')) continue;

            string pinName = key.Split('.')[1].ToLowerInvariant();
            string pinValue = value.StartsWith("D") ? value[1..] : value;

            context[$"pin_{pinName}"] = pinValue;
        }

        return context;
    }
}
