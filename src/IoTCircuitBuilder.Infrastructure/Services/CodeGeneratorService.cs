using IoTCircuitBuilder.Application.Interfaces;
using IoTCircuitBuilder.Domain.Entities;
using Microsoft.Extensions.Logging;
using Scriban;

namespace IoTCircuitBuilder.Infrastructure.Services;

public class CodeGeneratorService : ICodeGenerator
{
    private readonly ILogger<CodeGeneratorService> _logger;
    private readonly ILLMService _llmService;

    public CodeGeneratorService(ILogger<CodeGeneratorService> logger, ILLMService llmService)
    {
        _logger = logger;
        _llmService = llmService;
    }

    public async Task<string> GenerateCodeAsync(Dictionary<string, string> pinMapping, List<Component> components, string logicType, string role, string? sharedPayload = null)
    {
        _logger.LogInformation("Generating code with {MappingCount} pin assignments for logic type: {LogicType}, role: {Role}", pinMapping.Count, logicType, role);

        // 1. Generate Deterministic Header
        var header = GenerateDeterministicHeader(pinMapping, components, sharedPayload);

        // 2. Logic Synthesizer (Firmware Agent)
        IoTCircuitBuilder.Application.DTOs.FirmwareAgentResponse logicBlock = new();
        int maxRetries = 1;
        bool isValid = false;
        
        for (int i = 0; i <= maxRetries; i++)
        {
            _logger.LogInformation("Synthesizing Logic Block (Attempt {Attempt})", i + 1);
            logicBlock = await _llmService.GenerateFirmwareLogicAsync(header, role, components);

            // 3. Linker Validation Guard
            var validationError = ValidateLogicBlock(logicBlock, pinMapping);
            if (validationError == null)
            {
                isValid = true;
                break;
            }
            
            _logger.LogWarning("Logic Synthesizer validation failed: {Error}", validationError);
            if (i < maxRetries)
            {
                _logger.LogInformation("Retrying logic synthesis...");
            }
            else
            {
                _logger.LogError("Failed to generate valid logic after {MaxRetries} retries.", maxRetries);
                logicBlock.GlobalVariables = $"// ERROR: Logic strictly violated compiler rules: {validationError}\n// Fallback logic generated below.\n\n" + logicBlock.GlobalVariables;
            }
        }

        // 4. Link Firmware
        var code = LinkFirmware(header, logicBlock);

        _logger.LogInformation("Code generation complete: {LineCount} lines", code.Split('\n').Length);
        return code;
    }

    private string GenerateDeterministicHeader(Dictionary<string, string> pinMapping, List<Component> components, string? sharedPayload)
    {
        var libraries = CollectLibraries(components);
        var pinDefines = GeneratePinDefines(pinMapping);

        var sharedPayloadBlock = string.IsNullOrWhiteSpace(sharedPayload) ? "" : $@"// ─── Network Payload Struct ─────────────────────────
{sharedPayload}
";

        return $@"// ═══════════════════════════════════════════════════
// Auto-generated by IoT Circuit Builder
// Board: Arduino Uno R3
// Components: {components.Count}
// ═══════════════════════════════════════════════════

{string.Join("\n", libraries.Select(l => $"#include <{l}.h>"))}

{sharedPayloadBlock}
// ─── Pin Definitions ────────────────────────────────
{pinDefines}";
    }

    private string? ValidateLogicBlock(IoTCircuitBuilder.Application.DTOs.FirmwareAgentResponse logicBlock, Dictionary<string, string> pinMapping)
    {
        string combinedLogic = $"{logicBlock.GlobalVariables}\n{logicBlock.SetupCode}\n{logicBlock.LoopCode}";
        
        // Reject if it contains #define or struct 
        if (combinedLogic.Contains("#define ")) return "Illegal use of #define. The Firmware Agent must use provided macros.";
        if (combinedLogic.Contains("struct ")) return "Illegal use of struct. The Firmware Agent must use provided structs.";
        
        // Reject raw integer pins.
        // E.g. digitalWrite(2, HIGH) instead of digitalWrite(PIN_MACRO, HIGH)
        // Check for 'digitalWrite(' followed by a number
        if (System.Text.RegularExpressions.Regex.IsMatch(combinedLogic, @"(digitalWrite|analogWrite|pinMode)\s*\(\s*\d+\s*,"))
        {
             return "Detected raw integer pin usage. You MUST use the exact #define macros provided in the header.";
        }
        
        return null; // Valid
    }

    private string LinkFirmware(string header, IoTCircuitBuilder.Application.DTOs.FirmwareAgentResponse logicBlock)
    {
        return $@"{header}

// ─── Global Variables ───────────────────────────────
{logicBlock.GlobalVariables}

void setup() {{
  Serial.begin(115200);
  Serial.println(""IoT Circuit Builder - Initialized"");

  {logicBlock.SetupCode?.Replace("\n", "\n  ")}
}}

void loop() {{
  {logicBlock.LoopCode?.Replace("\n", "\n  ")}
}}
";
    }

    private List<string> CollectLibraries(List<Component> components)
    {
        var libs = new HashSet<string>();
        foreach (var comp in components)
        {
            foreach (var cl in comp.ComponentLibraries)
            {
                if (cl.IsRequired && cl.Library != null)
                    libs.Add(cl.Library.Name);
            }
        }
        return libs.ToList();
    }

    private string GeneratePinDefines(Dictionary<string, string> pinMapping)
    {
        var lines = new List<string>();
        foreach (var (key, value) in pinMapping)
        {
            // Skip power/ground pins and topological (component-to-component) mappings in defines
            if (value is "5V" or "3V3" or "GND" || value.Contains('.')) continue;

            string defineName = key.Replace(".", "_").ToUpperInvariant();
            // Extract numeric pin number: D3 → 3, A0 → A0
            string pinValue = value.StartsWith("D") ? value[1..] : value;
            lines.Add($"#define {defineName} {pinValue}");
        }
        return string.Join("\n", lines);
    }

    private string GenerateDeclarations(Dictionary<string, string> pinMapping, List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        var renderedBlocks = new HashSet<string>();

        foreach (var comp in components)
        {
            // Find instance indices for this component type
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "declaration"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);
                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;

                    var rendered = parsedTmpl.Render(pinValues).Trim();
                    if (!string.IsNullOrWhiteSpace(rendered) && !renderedBlocks.Contains(rendered))
                    {
                        lines.Add(rendered);
                        renderedBlocks.Add(rendered);
                    }
                }
            }
        }

        return string.Join("\n", lines);
    }

    private string GenerateSetup(Dictionary<string, string> pinMapping, List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        foreach (var comp in components)
        {
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "setup"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);
                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;
                    pinValues["var_name"] = $"{comp.Type}_{idx}";

                    var rendered = parsedTmpl.Render(pinValues);
                    // Indent each line
                    lines.AddRange(rendered.Split('\n').Select(l => $"  {l}"));
                }
            }
        }

        return string.Join("\n", lines);
    }

    private string GenerateLoop(Dictionary<string, string> pinMapping, List<Component> components)
    {
        var lines = new List<string>();
        var processed = new HashSet<string>();

        foreach (var comp in components)
        {
            var instances = pinMapping.Keys
                .Select(k => k.Split('.')[0])
                .Where(k => k.StartsWith(comp.Type))
                .Distinct()
                .ToList();

            foreach (var instance in instances)
            {
                if (processed.Contains(instance)) continue;
                processed.Add(instance);

                var idx = instance.Replace(comp.Type + "_", "");

                foreach (var tmpl in comp.CodeTemplates.Where(t => t.TemplateType == "loop"))
                {
                    var parsedTmpl = Template.Parse(tmpl.TemplateContent);
                    var pinValues = BuildTemplateContext(instance, pinMapping);
                    pinValues["instance_id"] = idx;
                    pinValues["display_name"] = comp.DisplayName ?? comp.Type;
                    pinValues["var_name"] = $"{comp.Type}_{idx}";

                    var rendered = parsedTmpl.Render(pinValues);
                    lines.AddRange(rendered.Split('\n').Select(l => $"  {l}"));
                }
            }
        }

        return string.Join("\n", lines);
    }

    /// <summary>
    /// Builds a template context dictionary like { "pin_out": "3", "pin_trig": "4" }
    /// from the mapping "ir_sensor_0.OUT" → "D3" (converts to pin_out → 3)
    /// </summary>
    private Dictionary<string, object> BuildTemplateContext(string instanceLabel, Dictionary<string, string> pinMapping)
    {
        var context = new Dictionary<string, object>();

        foreach (var (key, value) in pinMapping)
        {
            if (!key.StartsWith(instanceLabel + ".")) continue;

            // Skip topological pins (connections to other components) in the code context
            if (value.Contains('.')) continue;

            string pinName = key.Split('.')[1].ToLowerInvariant();
            string pinValue = value.StartsWith("D") ? value[1..] : value;

            context[$"pin_{pinName}"] = pinValue;
        }

        return context;
    }
}
